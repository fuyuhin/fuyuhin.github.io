<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Fuyuhin&#39;s Blog</title>
    <link>http://fuyuhin.me/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 14 May 2019 12:01:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>数据库记录批量插入</title>
      <link>http://fuyuhin.me/2019/Bulk-Insert-in-Database/</link>
      <guid>http://fuyuhin.me/2019/Bulk-Insert-in-Database/</guid>
      <pubDate>Sun, 12 May 2019 07:36:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;为什么要使用批量插入？因为批量插入要比逐条插入快。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>为什么要使用批量插入？因为批量插入要比逐条插入快。</p><a id="more"></a><blockquote><p>Use the multiple-row INSERT syntax to reduce communication overhead between the client and the server if you need to insert many rows</p><p>8.5.5 Bulk Data Loading for InnoDB Tables, MySQL 5.7 Reference Manual (<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html</a>)</p></blockquote><p>下面使用 MySQL 5.7 为例，看看批量插入会遇到什么问题。先创建一个数据库及表格<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> demo_db <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="keyword">USE</span> demo_db;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> animals (</span><br><span class="line"><span class="keyword">id</span> MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment</span><br><span class="line">,<span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">,tag_id MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">,PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">engine</span> = <span class="keyword">innodb</span> <span class="keyword">DEFAULT</span> <span class="keyword">charset</span> = utf8mb4;</span><br></pre></td></tr></table></figure></p><h2 id="使用-AUTO-INCREMENT"><a href="#使用-AUTO-INCREMENT" class="headerlink" title="使用 AUTO_INCREMENT"></a>使用 AUTO_INCREMENT</h2><p>不使用 AUTO_INCREMENT 意味着需要在数据库外部维护主键，并保证主键不冲突，否则两个包含相同主键的插入操作会导致后插入的操作失败。</p><p>如果主键使用了 AUTO_INCREMENT，那么插入一条记录后，如何获取刚刚插入的记录呢？ MySQL 提供了一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID()</code>函数</a>，返回使用了 AUTO_INCREMENT 的列最近一次 <code>INSERT</code> 生成的第一个值。故<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> = (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>())</span><br></pre></td></tr></table></figure></p><p>如果一次插入包含多个值，即一句 <code>INSERT</code> 创建多行记录，那么如何获取这些批量插入的记录呢？抱歉，MySQL 没有 <code>LAST_INSERT_ID_LIST()</code> 函数。但 MySQL 提供了 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_row-count" target="_blank" rel="noopener"><code>ROW_COUNT()</code>函数</a>，该函数可返回上次插入影响的记录数，也就是在命令行界面交互时返回的 <code>n rows affected</code> 的 n。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql root@localhost:demo_db&gt; INSERT INTO animals (name, tag_id) VALUES ('dog', 1), ('cat', 2), ('man', 9);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Time: 0.005s</span><br></pre></td></tr></table></figure></p><p>结合 <code>ROW_COUNT()</code>，使用 <code>LAST_INSERT_ID()</code> 仍可达到目的，先使用 <code>ROW_COUNT()</code> 获取插入的行数，<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> animals (<span class="keyword">name</span>, tag_id) <span class="keyword">VALUES</span> (<span class="string">'dog'</span>, <span class="number">1</span>), (<span class="string">'cat'</span>, <span class="number">2</span>), (<span class="string">'man'</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROW_COUNT</span>()</span><br></pre></td></tr></table></figure></p><p>上面例子 <code>SELECT ROW_COUNT()</code> 返回 3，然后<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>()) <span class="keyword">LIMIT</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>那为什么不结合在一起呢？像这样<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>()) <span class="keyword">LIMIT</span>(<span class="keyword">SELECT</span> <span class="keyword">ROW_COUNT</span>())</span><br></pre></td></tr></table></figure></p><p>原因是<code>ROW_COUNT()</code>不是一个可重复执行的操作，必须跟在修改操作后才有效。要保存 <code>ROW_COUNT()</code> 的值可以使用存储过程，或者数据库之外的程序。</p><h2 id="并发与事务"><a href="#并发与事务" class="headerlink" title="并发与事务"></a>并发与事务</h2><p>上面先 <code>INSERT</code> 再 <code>SELECT</code> 的操作在与别的修改操作并发的时候会遇到问题。如果别的修改操作先于 <code>SELECT</code> 完成，那么 <code>SELECT</code> 的结果会读到别的操作的修改结果，所以需要将两个操作放到同一个事务中处理。</p><p>在 SQL 标准中定义了四种<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" target="_blank" rel="noopener">隔离级别</a>，在最高隔离级别可串行化隔离下，所有事务强制串行，读取的每行数据加锁，可能会导致大量的超时与锁争用问题，故很少情况会使用该级别；而在可重复读的隔离级别中，会产生幻读问题，即在一个事务读取一个范围时，另一个事务在该范围插入了新记录，那么之前的事务再读取该范围记录时，会读取到幻行。为解决幻读问题，部分数据库支持了基于<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">多版本并发控制</a>实现的<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB" target="_blank" rel="noopener">快照隔离</a>功能。</p><p>在 MySQL 的实现中，默认的隔离级别是<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB" target="_blank" rel="noopener">可重复读</a>，而在 InnoDB 存储引擎中，在可重复读隔离级别下是默认启用快照隔离。</p><blockquote><p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. The query sees the changes made by transactions that committed before that point of time, and no changes made by later or uncommitted transactions</p><p>…</p><p>Consistent read is the default mode in which InnoDB processes SELECT statements in READ COMMITTED and REPEATABLE READ isolation levels.</p><p>14.7.2.3 Consistent Nonlocking Reads, MySQL 5.7 Reference Manual (<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a>)</p></blockquote><p>检查 MySQL 隔离级别<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| @@tx_isolation   |</span><br><span class="line">|<span class="comment">------------------|</span></span><br><span class="line">| READ-COMMITTED   |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure></p><p>将两个操作放到同一个事务中，事务的隔离级别设置为可重复读，并启用了多版本并发控制的快照隔离，那么问题就变成了先 <code>INSERT</code> 再 <code>SELECT</code> 的事务就能完全与别的事务隔离了吗？将上面 <code>INSERT</code> 语句修改一下，去掉后面的 <code>LIMIT</code>，启动两个事务，事务 1 先插入部分数据，不提交；事务 2 插入一条数据，提交；事务 1 再读取，提交。如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         T1                     Time  T2</span><br><span class="line">                                 +</span><br><span class="line">         START TRANSACTION     +-+-+  START TRANSACTION</span><br><span class="line">                                 |</span><br><span class="line">    INSERT A() VALUES(1),(2)   +-+</span><br><span class="line">                                 |</span><br><span class="line">                                 +-+  INSERT A() VALUES(3)</span><br><span class="line">                                 |</span><br><span class="line">                                 +-+  COMMIT</span><br><span class="line">                                 |</span><br><span class="line">SELECT * FROM A WHERE ID &gt;= 1  +-+</span><br><span class="line">              GET 1, 2, 3        |</span><br><span class="line">                                 |</span><br><span class="line">              COMMIT           +-+</span><br><span class="line">                                 v</span><br></pre></td></tr></table></figure></p><p>结果是，事务 1 能读取到事务 2 提交的数据。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>上面情况出现的原因是，事务 1 在 <code>SELECT</code> 前并没有生成快照。仔细看上面引用 MySQL 手册的第一句话“…a query a snapshot of the database at a point in time”，什么时候才是“in time”呢？可重复读，这个事务 1 只读了一次，并没有重复啊。那么在事务 1 开始后，马上获取最新一行记录，再执行后续操作，看看会怎样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                T1                   Time  T2</span><br><span class="line">                                      +</span><br><span class="line">              START TRANSACTION     +-+-+   START TRANSACTION</span><br><span class="line">                                      |</span><br><span class="line">SELECT * FROM A ORDER BY id LIMIT 1 +-+</span><br><span class="line">                                      |</span><br><span class="line">         INSERT A() VALUES(1),(2)   +-+</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  INSERT A() VALUES(3)</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  SELECT * FROM A</span><br><span class="line">                                      |         GET 3</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  COMMIT</span><br><span class="line">                                      |</span><br><span class="line">     SELECT * FROM A WHERE ID &gt;= 1  +-+</span><br><span class="line">                   GET 1, 2           |</span><br><span class="line">                                      |</span><br><span class="line">                   COMMIT           +-+</span><br><span class="line">                                      v</span><br></pre></td></tr></table></figure></p><p>现在好了，事务 1 与事务 2 都读取不到对方提交的数据了。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>]]></content:encoded>
      
      <comments>http://fuyuhin.me/2019/Bulk-Insert-in-Database/#disqus_thread</comments>
    </item>
    
    <item>
      <title>大坏蛋必须赢</title>
      <link>http://fuyuhin.me/2019/Bad-Guy-Must-Win/</link>
      <guid>http://fuyuhin.me/2019/Bad-Guy-Must-Win/</guid>
      <pubDate>Mon, 06 May 2019 14:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;吃晚饭的时候跟同事聊天，聊到最近的《复仇者联盟4：终局之战》。
      
      </description>
      
      <content:encoded><![CDATA[<p>吃晚饭的时候跟同事聊天，聊到最近的《复仇者联盟4：终局之战》。<a id="more"></a>我说不好看，同事问我哪部漫威的电影觉得好，我说了两部半，一部是《钢铁侠》，一部是《美国队长3：内战》，另外半部是《复仇者联盟3：无限战争》。为什么是半部呢？我说如果没有第四部，铺垫了十年的漫威宇宙结束在《复联3》，那它凭那一响指能算得上经典，可惜它没有。</p><p>下班回家路上在想，为什么这两部半会觉得好呢？以前看电影全凭直觉，好就是好，不作分析。现在粗略一想，这三部电影有个共同的地方，就是结局违背了观众的预期。《钢铁侠》是最后那句“我就是钢铁人”，《内战》是最后钢铁侠与美国队长的决裂，《复联3》就不用多说了。钢铁侠酝酿了半天，懒得解释了，不管，老子就是钢铁人，老子就是牛屄！当时我还在上高中，没看过多少电影，这么嚣张的超级英雄还是第一次见，好看。后两部则是大坏蛋都胜利了，以往这种超级英雄电影都一个模式，大坏蛋出现，主角修炼成长，大坏蛋倒霉，哪有大坏蛋大获全胜的？不按套路来，所以好看。若漫威宇宙前十年结束在《复联3》，那漫威舍得，漫威大气，漫威跟老子就是钢铁人一样牛屄。</p><p>《复联4》为什么不好呢？时空穿越，起死回生，狗尾续貂，落入俗套，罗素兄弟，败光家底。说好的不是《回到未来》，那灭霸是怎样“回到未来”的？古一法师都“剧透”了神奇博士五年后才会出现，那为什么不一路“剧透”到底？鹰眼跟黑寡妇到底经历了什么轰轰烈烈的婚外情才能抢着送死？不好意思不是粉丝真不知道。五一假期我在乡镇电影院激光杜比全景声巨幕厅 35 块钱看的，看完我还有点想退票。</p><p>现在我唯一能想起的《复联4》的闪光点是美国队长的那句“九头蛇万岁”，哈哈。</p><p>大坏蛋必须赢，回想过去还有哪部超级英雄电影的大坏蛋是赢了的呢？好像只有诺兰的《蝙蝠侠：黑暗骑士》里的小丑，那真不知道高到哪里去了。当初伏地魔要是打败了哈利波特该有多好，给小朋友们留下点童年阴影该有多棒。</p><p>不说了，今晚要看新鲜出炉的《权力的游戏》第八季第四集。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>]]></content:encoded>
      
      <comments>http://fuyuhin.me/2019/Bad-Guy-Must-Win/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《一个陌生女人的来信》剧评</title>
      <link>http://fuyuhin.me/2016/Letter-from-an-unknown-woman/</link>
      <guid>http://fuyuhin.me/2016/Letter-from-an-unknown-woman/</guid>
      <pubDate>Fri, 22 Apr 2016 13:00:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;上周周末晚上，我在哈尔滨工业大学的文体中心看了一场话剧，名为《一个陌生女人的来信》。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上周周末晚上，我在哈尔滨工业大学的文体中心看了一场话剧，名为《一个陌生女人的来信》。<br><a id="more"></a><br>这个话剧是这样的一个故事：1948年深冬，一位作家收到了一封厚厚的信，信中讲述了一个女子对他的毕生爱慕，而他却对此一无所知。</p><p>在少年时代，一位新邻居搬到女主人公家附近，少女对这位未曾谋面的新邻居充满好奇，从邻居的管家得知，他是一位作家，叫徐先生。但无奈母亲改嫁，少女也只能随着母亲迁居外地，但却始终无法忘记那位只见过一面的作家。</p><p>在青年时代，女主人公考上北平的大学，独自回到从前的家中。在一次学生游行中，她与徐先生重逢，但他已经认不出当初的那位少女了。徐先生开始追求女主人公。在浪漫的时光中，她与徐先生发生了关系。后来徐先生因事离开，却从此杳无音讯。女主人公在绝望的等待中发现自己怀孕了，因对作家的爱，她决定生下这个孩子。</p><p>孩子出世后，生活越发艰难。为了生计，她不得不在上流社会做交际花，当了一位军阀的情妇。在某个晚上，徐先生再次出现，同样，他也没认出她来。他与女主人公搭讪调情，带她离开了军阀。一夜的欢愉之后，她终于认识到徐先生的伪善与无情。因为得罪了军阀，她无依无靠，贫困潦倒。一个晚上孩子高烧不退，第二天便死去了。女主人公也预见她将要死亡的命运，凭着最后一丝力气，将往事写进信中寄给了作家。</p><p>最后作家读完信件，终于得知这位陌生女子的存在，心中后悔莫及，但却再也无法想起这位女子的面容了。</p><p>要在舞台上表现女主人公复杂的内心世界，这个话剧在表现手法上有很多让人眼前一亮的地方。</p><p><img src="https://web.archive.org/web/20161104032733im_/http://today.hit.edu.cn/uploadfiles/2016/4-15/2016415113219.jpg" alt></p><p>话剧还未开始，舞台已经摆放好布景和道具。舞台中央是一扇门，右边是徐先生家里，摆着书桌椅子；左边是一块比人高的、正方形的白色布板。话剧开始，作家打开信件，全场的灯光熄灭，一束白光从舞台后面打在布板上，我才知道那是一块屏幕。随着女子信中的念白，一位舞蹈演员在屏幕后跳起了独舞，屏幕上是舞姿的影子，时而高扬，时而低落。这个舞蹈，跟信中女子的情感可以说是相得益彰。</p><p>然后到了活泼的少年时代，在少女从窗户窥看徐先生家里的时候，走出来另一个重要人物。这个人物自称“里思维”，除了女主人公，没有别人能看到她。她跟少女说，只要你每次反思，她就会出现。有了这个人物，女主人公的内心挣扎就能转换为跟“里思维”的对话，也正是有了这些对话，才使两个半小时的话剧充实丰满起来。在母亲改嫁之后，是她告诉少女可以通过考北平的大学回到作家身边，但她也更早地预感到，回到北平，将是女主人公悲剧命运的开始。在得知怀了孩子并且作家杳无音讯的时候，是她告诉女主人公，作家对待别人的善是虚伪的，是为了掩饰内心的懦弱与无情，但女主人公却不愿意相信。在女主人公带着孩子被贵妇奚落欺负的时候，是她保护了女主人公；在军阀带女主人公去跳舞的时候，她摇晃着酒杯感叹上流社会生活的美好；在孩子高烧死去后，是她让女主人公接受这个残忍的事实；在表现女主人公死亡的时候，是她披着黑色斗篷开的枪。当然，女主人公死了，“里思维”也必须自杀。正是这个人物，让这个话剧有了更深层次的、预见命运的悲剧意味。</p><p><img src="/Pictures/Letter from an unknown women/tango.jpg" alt></p><p>最后一幕，作为某种“补偿”，三个时期的女主人公同台，置于某个虚幻的时空，作家与她们分别跳了一小段探戈。这个想法非常的好，可以说是神来一笔。</p><p>谢幕的时候导演提到，周六周日两场最后的某个部分（我忘了）和作家对待女主人公的态度是不同的，“影子舞”背后的舞蹈演员也用了不同的演员。导演说，我们或许都有过爱而不得的体会，我们遇到的人对我们的态度都是不同的，还有一些别的原因（我忘了）所以安排这样不同的两个版本。</p><p>接着提几点不足的地方。</p><p>服饰造型上的不够考究，使我非常容易从民国“穿越”回现代。饰演少女的演员的头发，是染过的、棕色的；而饰演作家的演员，头发是烫卷的，皮鞋闪亮，一身的西装从开始到结束没有换过。不同时期的女主人公由三个不同的演员饰演，虽然作家可以算作配角，但为了配合女主人公的年纪的变化，换几套衣服总是不难的。给观众时代的感受非常重要，因为这个故事不但是一个女性的悲剧，也是一个时代悲剧。</p><p>其次，幕间转换场景时播放的音乐不应该选用港台流行曲。虽然这些歌曲能看出是经过一番精心挑选的，也可以算是契合女主人公情感的，但流行曲和话剧的艺术气质毕竟不相符，前者是下里巴人，后者是阳春白雪。还有就是跟造型一样，时代感的问题。容祖儿的一首《习惯失恋》，尤其让我出戏。当然配乐也有选得恰到好处的，在话剧后半段出现的钢琴伴奏《What is a youth？》，在这种爱恋之下，问一句“What is a youth？”，相当微妙。</p><p>而最后一幕的探戈，尤其是阿根廷探戈，实在是难学，主角们本不是专业舞蹈演员，跳起来实在是蹩脚。</p><p>纵使有些许的缺点，但演员们的表演确实出色。独白有爆发，对戏有张力，确实能让人体会到女主人公的内心执着、不屈、悲痛与绝望。演员们都是来自不同院系的大一学生，能有那样精彩的表现已经非常难得。况且作为学生作品，条件资源有限，再作过多的要求的话，就是我过分挑剔了。</p><p>最后谈一下主题。</p><p>在观看过程中，附近有观众说女主人公傻，我们能这样评价女主人公吗？当然不能。我们怎能用现代的观念去评价她在那个时代所作出的选择是傻呢？我们现在所处的时代是一个同性恋可以合法结婚的时代，而在民国，一个女性要独立几乎是不可能的。换作是我，我也未必有倾尽一生的勇气和力量去追求爱情。</p><p>常常要引用鲁迅的话来说什么是悲剧：</p><blockquote><p>悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。 ——鲁迅</p></blockquote><p>那么在女主人公身上，什么是有价值的事物呢？我的答案是她对爱情纯真的憧憬、认真和执着。正是这种执着，使她不顾一切去追求爱情；也正是这种执着使她盲目，不愿看清作家的伪善和无情。</p><p>豆瓣同城的活动：<a href="https://www.douban.com/event/26534413/" target="_blank" rel="noopener">https://www.douban.com/event/26534413/</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>]]></content:encoded>
      
      <comments>http://fuyuhin.me/2016/Letter-from-an-unknown-woman/#disqus_thread</comments>
    </item>
    
    <item>
      <title>柏拉图与苏格拉底的谈话</title>
      <link>http://fuyuhin.me/2016/An-Introduction-to-Philosophy/</link>
      <guid>http://fuyuhin.me/2016/An-Introduction-to-Philosophy/</guid>
      <pubDate>Fri, 11 Mar 2016 11:17:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;上学期我选修了一个名为“趣味逻辑”的选修课，这是课程最后我写的论文，副标题为《写给理工科学生的哲学导论》。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上学期我选修了一个名为“趣味逻辑”的选修课，这是课程最后我写的论文，副标题为《写给理工科学生的哲学导论》。<br><a id="more"></a><br>多年以后，柏拉图在完成他的最后一本著作后点了一根烟，想起了他年轻时跟老师苏格拉底讨论的那个遥远的下午。</p><p>2015年，苏格拉底家的后花园。</p><p>柏：老师，最近有个科幻的念头挺困扰我的。</p><p>苏：说来听听。</p><p>柏：由于某种原因，几乎所有人类都灭绝了，仅剩一个或几个人类。这个人来到一个新的星球，这个原始的星球适合人类生存，但却没有现代社会的一切科技产物。那么这个人需要怎样的知识，才能重建人类的文明呢？</p><p>苏：既然问题已经提出，那么答案就不遥远了。你的想法是怎样的？</p><p>柏：这个人必须是个数学家。</p><p>苏：为什么是数学？</p><p>柏：因为数学是现代科学的基础。它们之间关系是这样的。（柏拉图在笔记本上画了这样的一个图：数学-&gt;物理-&gt;化学-&gt;生物-&gt;心理学-&gt;社会学-&gt;……）举个例子，化学中的一个方程式，两个氢气分子和一个氧气分子反应后产生两个水分子，化学从来不解释为什么会是这样，只是给出这个现象的描述。而要解释这个原因，原子到底是怎样重新组合的，则是物理知识了。再如，数学则提供了多维空间的可能性，而物理的现实宇宙只是这些可能性的某个实现罢了。也就是说，学科的划分，可以说是研究问题的层面不同罢了。而这些层次之中，数学是最基础的。</p><p>苏：你的意思是，人类文明中的科学是以数学为基础的，只要那个人精通数学，其他科学学科就能重建了是吧？</p><p>柏：我觉得是。至于人类文明中文化、艺术，我的看法是这样的：艺术，伟大的艺术作品，只能寄望于伟大的艺术家。让某个人写出莎士比亚的所有作品，不可能。唯有提高人类的数量，提高出现艺术家或者说天才的概率。而重建的文明自会有它的新的艺术，这便无法预料的了。文化也是同样道理。</p><p>苏：好。我有个问题，我从小就叫被教导：地球是围绕着太阳转的，“地心说”是不对的。我没有能力飞出太空去看一看，我怎么知道这个知识是不是真的？再如，物理学说这个物体是由一个一个肉眼不可看见的原子组成的，我又怎能确定究竟原子真的存在呢？问题是，我，或者你，为什么会相信这些科学理论呢？</p><p>柏：我们相信这些科学理论，是因为它能准确预测未来啊！譬如说知道了火星的轨迹方程，我就能告诉你，夜晚什么时候抬头看天就能看到火星。而“地心说”的确也能预测未来，但是“地心说”的模型相对于“日心说”的模型来说太复杂了，而且有些现象也不能很好地解释。所以可以这样说，科学的发展是以一个更好更简洁的模型替代原有模型的过程，而我们只是因为它能以一种更简洁的方式更好地解释更多的现象而选择去相信前者罢了。</p><p>苏：古时候也有一些说法，我怎么知道我眼前的世界是真实存在的，而不是某个魔鬼造出来的用来蒙蔽我的幻象呢？如你所说，“魔鬼造出来的幻象”这个模型实在是太粗糙了。<br>现在有些新的模型，譬如说，我怎么知道我眼前的世界是真实存在的，而不是某个超级计算机模拟出来的物理世界呢？</p><p>柏：（想了一会儿）这是一个无法证明，也无法证伪的命题。</p><p>苏：那么，是不是可以这样说，我们有可能存在于一个计算机模拟的物理世界的里面，而人类所有的科学理论都只是试图预测这个计算机的运行状态？</p><p>柏：非常有趣的说法。就像说基因就是源代码，人的身体只是这份代码编译出来的程序罢了。</p><p>苏：那么，既然这个世界的存在是值得怀疑的，究竟有什么是能够肯定它是存在的呢？</p><p>柏：（想了一会儿）至少存在一个正在思索这个问题的意识吧？</p><p>苏：（笑）那么，什么是意识呢？你真的能感觉到它的存在吗？</p><p>柏：意识只是大脑的一种功能罢了。至于感觉，难以描述。</p><p>苏：大脑是物理世界的事物，既然物理世界是值得怀疑的，那么大脑产生的意识就不值得怀疑了么？</p><p>柏：人类的历史里有对这个问题的答案吗？</p><p>苏：没有统一的答案。但大致有两类，一种认为科学理论所暗示的物质是存在的，譬如原子；另一种则认为上述物质是不存在的，唯一存在的是你这个“意识”，而现实世界是某种原因作用于这个“意识”而产生的结果，譬如神；或者纯粹是这个“意识”在做梦，梦中创造了现实世界的一切。相对于你所描述的科学理论，后者也有一套理论去解释现实世界，譬如神学。但也如你所说，这些说法都有太多牵强的地方，没有科学理论的精巧简洁。但在科学还未昌明的古代，这些说法是相当迷人的。</p><p>柏：现在我对这两者都不敢轻言相信。</p><p>苏：是啊。那么我们再次考察这个相信问题。你说我们只是选择去相信一个更简洁有效的模型，那么，为什么我们要这样去选择呢？</p><p>柏：（想了一会儿）因为它更合理。</p><p>苏：什么是“合理”？</p><p>柏：合乎理性的意思。</p><p>苏：什么是“理性”？</p><p>柏：简单地说，因果，逻辑。</p><p>苏：（笑）我就不再让你解释名词了。换个问题。我年轻的时候学微积分，对极限古怪的定义非常不解。定义都不能很好地理解，后面深入的定理更是莫名奇妙，以至于我的微积分成绩并不是很好。后来我听了一个老师讲数学史，提及为什么要那样定义极限。原因是，对于数学家来说，无穷始终是个谜，数学始终没有很好地解决有限和无穷的矛盾，而极限的定义恰恰巧妙地包含了这对矛盾。若某天出现了一个天才解决了这对矛盾，那么建立在极限之上的数学大厦便有崩塌的危机，譬如说历史上的第二次数学危机。问题来了，人类的逻辑是完美的吗？用人类的逻辑能用来研究存在问题吗？</p><p>柏：我只能说我不知道。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>]]></content:encoded>
      
      <comments>http://fuyuhin.me/2016/An-Introduction-to-Philosophy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>优雅的 elementary OS</title>
      <link>http://fuyuhin.me/2016/elementary-OS/</link>
      <guid>http://fuyuhin.me/2016/elementary-OS/</guid>
      <pubDate>Fri, 04 Mar 2016 10:02:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;简洁、实用、优雅，这是 elementary 带给我的美好的体验。&lt;br&gt;如果你在寻找一款 Linux 桌面发行版，快来试试它吧。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>简洁、实用、优雅，这是 elementary 带给我的美好的体验。<br>如果你在寻找一款 Linux 桌面发行版，快来试试它吧。<br><a id="more"></a></p><h3 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h3><p>elementary 的桌面非常简洁：底部是存放常用软件的 Dock，顶部是一条半透明的 Panel。</p><p>Panel 中间是日期和时间， 左边是软件列表，右边是音量、网络和电源等一些小图标。</p><p>值得注意的是，桌面上是<strong>不能</strong>放文件或者快捷方式等图标的，所以你永远不用担心那些乱七八糟的图标挡住那漂亮的壁纸啦！当然，这样设计的另一个原因是基于文件管理方面的考量，这个下面再细说。由于桌面并不是一个文件夹，所以在桌面点击鼠标右键并<strong>不会</strong>有快捷菜单出现。（这个特性在另一个非常流行的桌面环境 Gnome 3上也有哦。）</p><p><img src="/Pictures/elementary OS/Desktop.jpg" alt></p><h3 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h3><p>想像这样的场景：</p><p>当我需要打开一个不太常用的软件（它不在底部的 Dock），那么我就必须“找”到它。如果记得那软件的名字，我可以搜索一下。但由于那个软件不太常用，我往往是记不住它的名字的，那么我就不得不在一堆软件图标或者是软件列表中把它找出来。如果系统提供的软件列表并不友好，这个过程的效率就会非常低下。</p><p>而 elementary 提供了按软件功能分类的显示方式，对上述情况来说十分有效。因为当我需要打开某个软件时，我是非常明确它是用来干什么的；而且同一类别下的软件并不多，很容易就分辨出哪个是我需要的。</p><p><img src="/Pictures/elementary OS/Applications View by Category.jpg" alt></p><p>当然 elementary 也（默认）提供按网格平铺的方式来显示软件列表，每页15个图标。因为人的注意力是有限的，如果像别的一些桌面发行版那样在<strong>全屏幕</strong>按网格平铺的话，就会让人感觉找起软件来相当费劲。</p><p><img src="/Pictures/elementary OS/Applications View as Gird.jpg" alt></p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote><p>用户的习惯其实很多是坏的，好习惯是需要养成的。——fuyuhin</p></blockquote><p>把文件随便放在桌面其实是坏的习惯，做文件管理才是好的习惯。当你的文件非常的多，为了找某个文件而抓狂的时候，你就能体会到做好文件管理有多重要。</p><p>为了方便用户做文件管理，elementary 的文件管理器也有诸多特性来支持：</p><ul><li>多标签页，你再也不用打开多个窗口来复制粘贴文件啦</li><li>支持以网格平铺、详细列表、按路径分栏这三种视图（下图为按路径分栏视图）</li><li>当你关闭文件管理器，下次你再打开它，它的每个标签页的文件夹位置、显示方式仍旧是上次关闭前的状态。</li></ul><p><img src="/Pictures/elementary OS/Files View in Columns.jpg" alt></p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>工作区的概念在 Linux 的众多桌面环境中很早就有了：在只有一个屏幕的情况下创建多个桌面，一个桌面为一个工作区。在打开很多窗口又不能关闭的情况下，这个功能非常有用。</p><p><img src="/Pictures/elementary OS/Multitasking View.jpg" alt></p><p>elementary 这方面的细节特别赞：</p><ul><li>启动多窗口视图后，当前工作区的所有软件窗口会平铺起来，下方有该工作区的缩略图</li><li>缩略图里有该工作区打开的软件图标，鼠标移至缩略图会显示关闭该工作区的按钮，按下后会关闭该工作区所有窗口</li><li>能直接用鼠标把某个软件窗口拖到另一个工作区</li><li>工作区的快捷键十分直观：“ ⌘ + S ”能启动多窗口视图，“ ⌘ + ← / →”能直接切换到左边/右边的工作区</li></ul><p>譬如在写这篇文章的时候（见上图），我在第一工作区写作，在第二工作区预览文章页面，在第三工作区截图和处理图片，切换起来非常的方便，并不需要最小化这个窗口再最大化那个窗口，效率非常的高。</p><h3 id="系统通知"><a href="#系统通知" class="headerlink" title="系统通知"></a>系统通知</h3><p>这个系统通知实在是太贴心了，当你遇到</p><ul><li>播放下一首歌曲</li><li>电脑电量快不足</li><li>Terminal（终端模拟器）的任务完成</li><li>调节音量、屏幕亮度</li><li>连上/断开 Wifi</li><li>浏览器页面发出消息（譬如微信）</li></ul><p>等等情况，都会在屏幕右上角弹出一则通知，根据通知的类型停留长短不同的一段时间，再消失不见。</p><p><img src="/Pictures/elementary OS/Messages.jpg" alt></p><h3 id="软件-UI"><a href="#软件-UI" class="headerlink" title="软件 UI"></a>软件 UI</h3><p>elementary 强调的一点是开箱即用，为此开发者们开发了很多系统内置软件，譬如音乐播放器、浏览器、编辑器等等。这些工具是如此的实用和美观，以至于用户不再需要下载别的软件了。开发者开发这些软件遵守着他们独有的开发守则：<a href="https://elementary.io/en/docs/human-interface-guidelines" target="_blank" rel="noopener">Human Interface Guidelines</a>。这些软件在用户界面上有这样的特点：</p><ul><li>标题栏不再仅仅是标题栏。标题栏若是仅仅显示标题和摆放几个窗口按钮，实在是太浪费空间了。在一些软件中，显示标题栏并不重要，所以这些应用连标题都不显示了，取而代之的是一些常用操作的工具按钮，譬如文件的保存和打开，浏览器和文件管理器的前进后退等等。</li><li>最小化按钮被取消了，关闭按钮和最大化按钮在标题栏左右两端对称摆放。在工作区如此的好用的情况下，最小化按钮就显低效和没有必要了。但最小化的功能还是有的：单击 Dock 上该软件的图标即可。</li><li>没有菜单栏。当然，一些功能复杂的软件安装之后，它们原有的菜单栏还是会保留的，譬如 LibreOffice，GIMP，Firefox等等。</li></ul><p><img src="/Pictures/elementary OS/Others.jpg" alt></p><p>（上图从左至右依次为计算器、编辑器、浏览器。）</p><h3 id="内置软件"><a href="#内置软件" class="headerlink" title="内置软件"></a>内置软件</h3><p>这些内置软件我挑几个特别喜欢的说一下亮点，其余就不再细说了：</p><ul><li>Terminal 有标签页、搜索功能。能搜索 Terminal 实在是棒啊！<br><img src="/Pictures/elementary OS/Terminal.jpg" alt></li><li>Screenshot 有延时截图、区域截图，十分实用。别问我是如何用 Screenshot 截 Screenshot 的……<br><img src="/Pictures/elementary OS/Screenshot Tool.jpg" alt></li><li>Music 平铺专辑封面视图。你喜欢 My Little Airport 吗？<br><img src="/Pictures/elementary OS/Music.jpg" alt></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我现在使用的是 elementary OS 0.3.2 Freya，它是基于 Ubuntu 14.04 LTS 修改的 Linux 发行版，这意味着它跟 Ubuntu 有一样的稳定性能和庞大的软件仓库。还有一点，它的系统语言是有中文的。</p><p>我把 elementary OS 作为日常使用的操作系统已经有两年多了，在不断地尝试的过程中充满了惊喜和新的发现。衷心感谢 elementary 的开发者和 Linux 社区。我非常喜欢这个发行版，希望你也喜欢。</p><p>elementary OS 的主页：<a href="https://elementary.io" target="_blank" rel="noopener">https://elementary.io</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>]]></content:encoded>
      
      <comments>http://fuyuhin.me/2016/elementary-OS/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
