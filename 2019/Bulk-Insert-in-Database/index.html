<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Fuyuhin's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>数据库记录批量插入 - Fuyuhin's Blog</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Fuyuhin's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives/" class="head-nav__link">Archives</a></li><li class="head-nav__item"><a href="/about/" class="head-nav__link">About</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2019-05-12T07:36:54.000Z" class="post__time">May 12, 2019</time><h1 class="post__title"><a href="/2019/Bulk-Insert-in-Database/">数据库记录批量插入</a></h1></header><div class="post__main echo"><p>为什么要使用批量插入？因为批量插入要比逐条插入快。</p>
<a id="more"></a>
<blockquote>
<p>Use the multiple-row INSERT syntax to reduce communication overhead between the client and the server if you need to insert many rows</p>
<p>8.5.5 Bulk Data Loading for InnoDB Tables, MySQL 5.7 Reference Manual (<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html</a>)</p>
</blockquote>
<p>下面使用 MySQL 5.7 为例，看看批量插入会遇到什么问题。先创建一个数据库及表格<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> demo_db <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="keyword">USE</span> demo_db;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> animals (</span><br><span class="line">	<span class="keyword">id</span> MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment</span><br><span class="line">	,<span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">	,tag_id MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">	,PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">	) <span class="keyword">engine</span> = <span class="keyword">innodb</span> <span class="keyword">DEFAULT</span> <span class="keyword">charset</span> = utf8mb4;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-AUTO-INCREMENT"><a href="#使用-AUTO-INCREMENT" class="headerlink" title="使用 AUTO_INCREMENT"></a>使用 AUTO_INCREMENT</h2><p>不使用 AUTO_INCREMENT 意味着需要在数据库外部维护主键，并保证主键不冲突，否则两个包含相同主键的插入操作会导致后插入的操作失败。</p>
<p>如果主键使用了 AUTO_INCREMENT，那么插入一条记录后，如何获取刚刚插入的记录呢？ MySQL 提供了一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID()</code>函数</a>，返回使用了 AUTO_INCREMENT 的列最近一次 <code>INSERT</code> 生成的第一个值。故<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> = (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>())</span><br></pre></td></tr></table></figure></p>
<p>如果一次插入包含多个值，即一句 <code>INSERT</code> 创建多行记录，那么如何获取这些批量插入的记录呢？抱歉，MySQL 没有 <code>LAST_INSERT_ID_LIST()</code> 函数。但 MySQL 提供了 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_row-count" target="_blank" rel="noopener"><code>ROW_COUNT()</code>函数</a>，该函数可返回上次插入影响的记录数，也就是在命令行界面交互时返回的 <code>n rows affected</code> 的 n。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql root@localhost:demo_db&gt; INSERT INTO animals (name, tag_id) VALUES ('dog', 1), ('cat', 2), ('man', 9);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Time: 0.005s</span><br></pre></td></tr></table></figure></p>
<p>结合 <code>ROW_COUNT()</code>，使用 <code>LAST_INSERT_ID()</code> 仍可达到目的，先使用 <code>ROW_COUNT()</code> 获取插入的行数，<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> animals (<span class="keyword">name</span>, tag_id) <span class="keyword">VALUES</span> (<span class="string">'dog'</span>, <span class="number">1</span>), (<span class="string">'cat'</span>, <span class="number">2</span>), (<span class="string">'man'</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROW_COUNT</span>()</span><br></pre></td></tr></table></figure></p>
<p>上面例子 <code>SELECT ROW_COUNT()</code> 返回 3，然后<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>()) <span class="keyword">LIMIT</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>那为什么不结合在一起呢？像这样<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= (<span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>()) <span class="keyword">LIMIT</span>(<span class="keyword">SELECT</span> <span class="keyword">ROW_COUNT</span>())</span><br></pre></td></tr></table></figure></p>
<p>原因是<code>ROW_COUNT()</code>不是一个可重复执行的操作，必须跟在修改操作后才有效。要保存 <code>ROW_COUNT()</code> 的值可以使用存储过程，或者数据库之外的程序。</p>
<h2 id="并发与事务"><a href="#并发与事务" class="headerlink" title="并发与事务"></a>并发与事务</h2><p>上面先 <code>INSERT</code> 再 <code>SELECT</code> 的操作在与别的修改操作并发的时候会遇到问题。如果别的修改操作先于 <code>SELECT</code> 完成，那么 <code>SELECT</code> 的结果会读到别的操作的修改结果，所以需要将两个操作放到同一个事务中处理。</p>
<p>在 SQL 标准中定义了四种<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" target="_blank" rel="noopener">隔离级别</a>，在最高隔离级别可串行化隔离下，所有事务强制串行，读取的每行数据加锁，可能会导致大量的超时与锁争用问题，故很少情况会使用该级别；而在可重复读的隔离级别中，会产生幻读问题，即在一个事务读取一个范围时，另一个事务在该范围插入了新记录，那么之前的事务再读取该范围记录时，会读取到幻行。为解决幻读问题，部分数据库支持了基于<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">多版本并发控制</a>实现的<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB" target="_blank" rel="noopener">快照隔离</a>功能。</p>
<p>在 MySQL 的实现中，默认的隔离级别是<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB" target="_blank" rel="noopener">可重复读</a>，而在 InnoDB 存储引擎中，在可重复读隔离级别下是默认启用快照隔离。</p>
<blockquote>
<p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time. The query sees the changes made by transactions that committed before that point of time, and no changes made by later or uncommitted transactions</p>
<p>…</p>
<p>Consistent read is the default mode in which InnoDB processes SELECT statements in READ COMMITTED and REPEATABLE READ isolation levels.</p>
<p>14.7.2.3 Consistent Nonlocking Reads, MySQL 5.7 Reference Manual (<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a>)</p>
</blockquote>
<p>检查 MySQL 隔离级别<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| @@tx_isolation   |</span><br><span class="line">|<span class="comment">------------------|</span></span><br><span class="line">| READ-COMMITTED   |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>将两个操作放到同一个事务中，事务的隔离级别设置为可重复读，并启用了多版本并发控制的快照隔离，那么问题就变成了先 <code>INSERT</code> 再 <code>SELECT</code> 的事务就能完全与别的事务隔离了吗？将上面 <code>INSERT</code> 语句修改一下，去掉后面的 <code>LIMIT</code>，启动两个事务，事务 1 先插入部分数据，不提交；事务 2 插入一条数据，提交；事务 1 再读取，提交。如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         T1                     Time  T2</span><br><span class="line">                                 +</span><br><span class="line">         START TRANSACTION     +-+-+  START TRANSACTION</span><br><span class="line">                                 |</span><br><span class="line">    INSERT A() VALUES(1),(2)   +-+</span><br><span class="line">                                 |</span><br><span class="line">                                 +-+  INSERT A() VALUES(3)</span><br><span class="line">                                 |</span><br><span class="line">                                 +-+  COMMIT</span><br><span class="line">                                 |</span><br><span class="line">SELECT * FROM A WHERE ID &gt;= 1  +-+</span><br><span class="line">              GET 1, 2, 3        |</span><br><span class="line">                                 |</span><br><span class="line">              COMMIT           +-+</span><br><span class="line">                                 v</span><br></pre></td></tr></table></figure></p>
<p>结果是，事务 1 能读取到事务 2 提交的数据。</p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>上面情况出现的原因是，事务 1 在 <code>SELECT</code> 前并没有生成快照。仔细看上面引用 MySQL 手册的第一句话“…a query a snapshot of the database at a point in time”，什么时候才是“in time”呢？可重复读，这个事务 1 只读了一次，并没有重复啊。那么在事务 1 开始后，马上获取最新一行记录，再执行后续操作，看看会怎样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                T1                   Time  T2</span><br><span class="line">                                      +</span><br><span class="line">              START TRANSACTION     +-+-+   START TRANSACTION</span><br><span class="line">                                      |</span><br><span class="line">SELECT * FROM A ORDER BY id LIMIT 1 +-+</span><br><span class="line">                                      |</span><br><span class="line">         INSERT A() VALUES(1),(2)   +-+</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  INSERT A() VALUES(3)</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  SELECT * FROM A</span><br><span class="line">                                      |         GET 3</span><br><span class="line">                                      |</span><br><span class="line">                                      +-+  COMMIT</span><br><span class="line">                                      |</span><br><span class="line">     SELECT * FROM A WHERE ID &gt;= 1  +-+</span><br><span class="line">                   GET 1, 2           |</span><br><span class="line">                                      |</span><br><span class="line">                   COMMIT           +-+</span><br><span class="line">                                      v</span><br></pre></td></tr></table></figure></p>
<p>现在好了，事务 1 与事务 2 都读取不到对方提交的数据了。</p>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"></a></p>
</div><footer class="post__foot u-cf"><a href="/2019/Bulk-Insert-in-Database/#disqus_thread" class="post__foot-link u-fr"></a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2019 fuyuhin</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/2019/Bad-Guy-Must-Win/" class="page-menu__link icon-arrow-right"></a></li></menu></footer></body></html>